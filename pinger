#!/usr/bin/env python

# Copyright 2014 Mike Sampson

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import yaml
import time
import gping
import bottle
import requests
import argparse
import collections
import multiprocessing


def parse_config(config_file):
    config = yaml.load(open(config_file).read())

    nodes = config['nodes']

    for node in nodes:
        node['up'] = True

    pushover = config['pushover']

    hipchat = config['hipchat']

    return (nodes, pushover, hipchat)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('config', help='config file')

    return parser.parse_args()


class Pinger:

    def __init__(self):
        self.counter = collections.Counter()
        self.gp = gping.GPing()

        self.args = parse_args()

        nodes, pushover, hipchat = parse_config(self.args.config)

        self.nodes = nodes
        self.nodes_down = multiprocessing.Manager().list()
        self.pushover = pushover
        self.hipchat = hipchat


    def pushover_alert(self, msg, priority = 0):
        payload = {
            "user": self.pushover['user'],
            "token": self.pushover['token'],
            'priority': priority,
            'message': msg
        }

        if priority == 2:
            payload['retry'] = 300
            payload['expire'] = 3600

        r = requests.post('https://api.pushover.net/1/messages.json', data = payload)

        if r.status_code != requests.codes.ok:
            raise r.raise_for_status()


    def hipchat_alert(self, msg, color):
        payload = {
            'format': 'json',
            'auth_token': self.hipchat['token'],
            'room_id': self.hipchat['room'],
            'from': self.hipchat['from'],
            'message': msg,
            'color': color
        }

        r = requests.post('https://api.hipchat.com/v1/rooms/message', data = payload)

        if r.status_code != requests.codes.ok:
            raise r.raise_for_status()


    def lookup_node(self, address):
        for node in self.nodes:
            if node['ip'] == address:
                return node
        return None


    def lookup_node_by_name(self, name):
        for node in self.nodes:
            if node['name'] == name:
                return node
        return None


    def ping_callback(self, ping):
        if ping['success']:
            self.counter[ping['dest_addr']] += 1


    def loop(self):
        self.counter.clear()
        for x in range(3):
            time.sleep(1)
            for node in self.nodes:
                self.gp.send(node['ip'], self.ping_callback)

        self.gp.join()

        for node in self.nodes:
            if node['name'] in self.nodes_down:
                print('{} is configured to be down.'.format(node['name']))
                continue
            if self.counter[node['ip']] == 0 and node['up']:
                node['up'] = False
                msg =  '%s (%s) is down' % (node['name'], node['ip'])
                print(msg)
                self.pushover_alert(msg, priority = 2)
                self.hipchat_alert(msg, color = 'red')
            elif self.counter[node['ip']] > 0 and not node['up']:
                node['up'] = True
                msg =  '%s (%s) is up' % (node['name'], node['ip'])
                print(msg)
                self.pushover_alert(msg)
                self.hipchat_alert(msg, color = 'green')


    def run(self):
        p = multiprocessing.Process(target = self.api_serve)
        p.start()

        while True:
            self.loop()
            print('-- ping --')
            time.sleep(60)


    def api_serve(self):
        bottle.route('/up/<host>', callback = self.api_up)
        bottle.route('/down/<host>', callback = self.api_down)
        bottle.run(host = 'localhost', port = 8080)


    def api_up(self, host):
        node = self.lookup_node_by_name(host)

        if node:
            print('up', host)
            if node['name'] in self.nodes_down:
                self.nodes_down.remove(node['name'])
        else:
            bottle.abort(404, 'Invalid host.')


    def api_down(self, host):
        node = self.lookup_node_by_name(host)

        if node:
            print('down', host)
            if node['name'] not in self.nodes_down:
                self.nodes_down.append(node['name'])
        else:
            bottle.abort(404, 'Invalid host.')


def main():

    pinger = Pinger()

    pinger.run()


if __name__ == '__main__':
    main()
